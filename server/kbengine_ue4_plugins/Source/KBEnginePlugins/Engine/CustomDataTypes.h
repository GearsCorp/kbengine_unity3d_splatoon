/*
	Generated by KBEngine!
	Please do not modify this file!
	tools = kbcmd
*/

#pragma once
#include "KBECommon.h"
#include "KBETypes.h"
#include "MemoryStream.h"
#include "Bundle.h"
#include "DataTypes.h"


class KBENGINEPLUGINS_API DATATYPE_AVATAR_INFOS : DATATYPE_BASE
{
public:
	void createFromStreamEx(MemoryStream& stream, AVATAR_INFOS& datas);
	void addToStreamEx(Bundle& stream, const AVATAR_INFOS& v);
};


class KBENGINEPLUGINS_API DATATYPE_AVATAR_INFOS_LIST : DATATYPE_BASE
{
public:
	class KBENGINEPLUGINS_API DATATYPE__AVATAR_INFOS_LIST_values_ArrayType_ChildArray : public DATATYPE_BASE
	{
	public:
		DATATYPE_AVATAR_INFOS itemType;

		void createFromStreamEx(MemoryStream& stream, TArray<AVATAR_INFOS>& datas)
		{
			uint32 size = stream.readUint32();
			while(size > 0)
			{
				--size;
				itemType.createFromStreamEx(stream, datas.EmplaceAt_GetRef(datas.Num()));
			};

		}

		void addToStreamEx(Bundle& stream, const TArray<AVATAR_INFOS>& v)
		{
			stream.writeUint32((uint32)v.Num());
			for(int i=0; i<v.Num(); ++i)
			{
				itemType.addToStreamEx(stream, v[i]);
			};
		}
	};

	DATATYPE__AVATAR_INFOS_LIST_values_ArrayType_ChildArray values_DataType;

	void createFromStreamEx(MemoryStream& stream, AVATAR_INFOS_LIST& datas);
	void addToStreamEx(Bundle& stream, const AVATAR_INFOS_LIST& v);
};


class KBENGINEPLUGINS_API DATATYPE_MATCHING_INFOS : DATATYPE_BASE
{
public:
	void createFromStreamEx(MemoryStream& stream, MATCHING_INFOS& datas);
	void addToStreamEx(Bundle& stream, const MATCHING_INFOS& v);
};


class KBENGINEPLUGINS_API DATATYPE_MATCHING_INFOS_LIST : DATATYPE_BASE
{
public:
	class KBENGINEPLUGINS_API DATATYPE__MATCHING_INFOS_LIST_values_ArrayType_ChildArray : public DATATYPE_BASE
	{
	public:
		DATATYPE_MATCHING_INFOS itemType;

		void createFromStreamEx(MemoryStream& stream, TArray<MATCHING_INFOS>& datas)
		{
			uint32 size = stream.readUint32();
			while(size > 0)
			{
				--size;
				itemType.createFromStreamEx(stream, datas.EmplaceAt_GetRef(datas.Num()));
			};

		}

		void addToStreamEx(Bundle& stream, const TArray<MATCHING_INFOS>& v)
		{
			stream.writeUint32((uint32)v.Num());
			for(int i=0; i<v.Num(); ++i)
			{
				itemType.addToStreamEx(stream, v[i]);
			};
		}
	};

	DATATYPE__MATCHING_INFOS_LIST_values_ArrayType_ChildArray values_DataType;

	void createFromStreamEx(MemoryStream& stream, MATCHING_INFOS_LIST& datas);
	void addToStreamEx(Bundle& stream, const MATCHING_INFOS_LIST& v);
};


class KBENGINEPLUGINS_API DATATYPE_FS_ENTITY_DATA : DATATYPE_BASE
{
public:
	void createFromStreamEx(MemoryStream& stream, FS_ENTITY_DATA& datas);
	void addToStreamEx(Bundle& stream, const FS_ENTITY_DATA& v);
};


class KBENGINEPLUGINS_API DATATYPE_FS_FRAME_DATA : DATATYPE_BASE
{
public:
	class KBENGINEPLUGINS_API DATATYPE__FS_FRAME_DATA_operation_ArrayType_ChildArray : public DATATYPE_BASE
	{
	public:
		DATATYPE_FS_ENTITY_DATA itemType;

		void createFromStreamEx(MemoryStream& stream, TArray<FS_ENTITY_DATA>& datas)
		{
			uint32 size = stream.readUint32();
			while(size > 0)
			{
				--size;
				itemType.createFromStreamEx(stream, datas.EmplaceAt_GetRef(datas.Num()));
			};

		}

		void addToStreamEx(Bundle& stream, const TArray<FS_ENTITY_DATA>& v)
		{
			stream.writeUint32((uint32)v.Num());
			for(int i=0; i<v.Num(); ++i)
			{
				itemType.addToStreamEx(stream, v[i]);
			};
		}
	};

	DATATYPE__FS_FRAME_DATA_operation_ArrayType_ChildArray operation_DataType;

	void createFromStreamEx(MemoryStream& stream, FS_FRAME_DATA& datas);
	void addToStreamEx(Bundle& stream, const FS_FRAME_DATA& v);
};


class KBENGINEPLUGINS_API DATATYPE_FS_FRAME_LIST : DATATYPE_BASE
{
public:
	class KBENGINEPLUGINS_API DATATYPE__FS_FRAME_LIST_values_ArrayType_ChildArray : public DATATYPE_BASE
	{
	public:
		DATATYPE_FS_FRAME_DATA itemType;

		void createFromStreamEx(MemoryStream& stream, TArray<FS_FRAME_DATA>& datas)
		{
			uint32 size = stream.readUint32();
			while(size > 0)
			{
				--size;
				itemType.createFromStreamEx(stream, datas.EmplaceAt_GetRef(datas.Num()));
			};

		}

		void addToStreamEx(Bundle& stream, const TArray<FS_FRAME_DATA>& v)
		{
			stream.writeUint32((uint32)v.Num());
			for(int i=0; i<v.Num(); ++i)
			{
				itemType.addToStreamEx(stream, v[i]);
			};
		}
	};

	DATATYPE__FS_FRAME_LIST_values_ArrayType_ChildArray values_DataType;

	void createFromStreamEx(MemoryStream& stream, FS_FRAME_LIST& datas);
	void addToStreamEx(Bundle& stream, const FS_FRAME_LIST& v);
};


